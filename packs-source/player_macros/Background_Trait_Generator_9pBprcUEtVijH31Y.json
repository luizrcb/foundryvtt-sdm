{
  "name": "Background Trait Generator",
  "type": "script",
  "command": "let actor = game.user?.character || canvas?.tokens?.controlled[0]?.actor;\n\nif (!actor) {\n  ui.notifications.error(game.i18n.localize('SDM.BackgroundInvalidCharacter'));\n  return;\n}\n\n// ----- 1. Sorteio das 10 linhas -----\nconst BACKGROUND_TABLE = Array.from({ length: 40 }, (_, i) => ({\n  flavor: game.i18n.localize(`SDM.BackgroundRow${String(i + 1).padStart(2, '0')}.Flavor`),\n  role1: game.i18n.localize(`SDM.BackgroundRow${String(i + 1).padStart(2, '0')}.Role1`),\n  role2: game.i18n.localize(`SDM.BackgroundRow${String(i + 1).padStart(2, '0')}.Role2`),\n  task: game.i18n.localize(`SDM.BackgroundRow${String(i + 1).padStart(2, '0')}.Task`),\n  spin: game.i18n.localize(`SDM.BackgroundRow${String(i + 1).padStart(2, '0')}.Spin`)\n}));\n\nfunction roll10d40(table) {\n  const results = [];\n  while (results.length < 10) {\n    const r = Math.floor(Math.random() * table.length);\n    if (!results.includes(r)) results.push(r);\n  }\n  return results.map(i => ({ index: i + 1, ...table[i] }));\n}\n\n// Ordem dos dois primeiros campos do preview.\nlet previewOrder = ['flavor', 'role'];\n\n// ----- 2. HTML do Dialog -----\nfunction buildDialogContent(rows) {\n  let html = `\n    <style>\n      .background-table { width: 100%; border-collapse: collapse; margin-bottom: 10px; }\n      .background-table th, .background-table td { border: 1px solid #444; padding: 4px 6px; text-align: left; }\n      .background-table th { background-color: #222; color: #fff; }\n      .background-table tbody tr:nth-child(odd) { background-color: #2a2a2a; }\n      .background-table tbody tr:nth-child(even) { background-color: #1f1f1f; }\n      .preview-inputs input { width: 100%; margin-bottom: 4px; padding: 4px; background-color: #333; border: 1px solid #555; color: #fff; }\n      .preview-inputs label { font-weight: bold; margin-bottom: 2px; display: block; }\n      #reroll-dice { color: red; cursor:pointer; margin-bottom:5px; display:inline-block; }\n      #swap-order { cursor: pointer; margin-left: 8px; }\n      .preview-toolbar { display:flex; align-items:center; gap:8px; margin-bottom:6px; }\n      .muted { opacity: 0.85; font-size: 0.9em; }\n    </style>\n    <div style=\"display:flex; justify-content:flex-end;\">\n      <div style=\"color: red; margin-bottom:5px;\">\n        <span style=\"color: black\"><b>${game.i18n.localize('SDM.BackgroundReroll')}</b></span>\n        <i class=\"fas fa-dice fa-lg\" id=\"reroll-dice\" title=\"${game.i18n.localize('SDM.BackgroundReroll')}\" style=\"cursor: pointer\"></i>\n      </div>\n    </div>\n    <table class=\"background-table\">\n      <thead>\n        <tr>\n          <th></th>\n          <th>${game.i18n.localize('SDM.BackgroundFlavor')}</th>\n          <th>${game.i18n.localize('SDM.BackgroundRole1')}</th>\n          <th>${game.i18n.localize('SDM.BackgroundRole2')}</th>\n          <th>${game.i18n.localize('SDM.BackgroundTask')}</th>\n          <th>${game.i18n.localize('SDM.BackgroundSpin')}</th>\n        </tr>\n      </thead>\n      <tbody>\n  `;\n\n  rows.forEach((row, i) => {\n    html += `<tr data-row=\"${i}\">\n      <td><input type=\"checkbox\" class=\"row-select\"></td>\n      <td><input type=\"checkbox\" class=\"cell-select\" data-col=\"flavor\"> ${row.flavor}</td>\n      <td><input type=\"checkbox\" class=\"cell-select\" data-col=\"role1\"> ${row.role1}</td>\n      <td><input type=\"checkbox\" class=\"cell-select\" data-col=\"role2\"> ${row.role2}</td>\n      <td><input type=\"checkbox\" class=\"cell-select\" data-col=\"task\"> ${row.task}</td>\n      <td><input type=\"checkbox\" class=\"cell-select\" data-col=\"spin\"> ${row.spin}</td>\n    </tr>`;\n  });\n\n  html += `</tbody></table>\n    <div class=\"preview-inputs\">\n      <div class=\"preview-toolbar\">\n        <label style=\"margin:0;\"><strong>${game.i18n.localize('SDM.BackgroundEditablePreview')}</strong></label>\n        <i style=\"cursor:pointer; margin-left: 5px;\" id=\"swap-order\" class=\"fas fa-exchange-alt\" title=\"${game.i18n.localize('SDM.BackgroundSwapOrder')}\"> ${game.i18n.localize('SDM.BackgroundSwapOrder')}</i>\n        <span class=\"muted\" id=\"order-hint\"></span>\n      </div>\n      <div id=\"preview-fields\"></div>\n    </div>`;\n  return html;\n}\n\n// Renderiza os inputs do preview conforme a ordem atual.\nfunction renderPreviewInputs(html) {\n  const container = html.querySelector('#preview-fields');\n  if (!container) return;\n\n  const current = {\n    flavor: html.querySelector('#preview-flavor')?.value ?? '',\n    role:   html.querySelector('#preview-role')?.value ?? '',\n    task:   html.querySelector('#preview-task')?.value ?? '',\n    spin:   html.querySelector('#preview-spin')?.value ?? ''\n  };\n\n  const flavorPh = game.i18n.localize('SDM.BackgroundFlavor');\n  const rolePh   = game.i18n.localize('SDM.BackgroundRole');\n  const taskPh   = game.i18n.localize('SDM.BackgroundTask');\n  const spinPh   = game.i18n.localize('SDM.BackgroundSpin');\n\n  const firstField  = previewOrder[0];\n  const secondField = previewOrder[1];\n\n  container.innerHTML = `\n    <input type=\"text\" id=\"preview-${firstField}\"  placeholder=\"${firstField  === 'flavor' ? flavorPh : rolePh}\">\n    <input type=\"text\" id=\"preview-${secondField}\" placeholder=\"${secondField === 'flavor' ? flavorPh : rolePh}\">\n    <input type=\"text\" id=\"preview-task\" placeholder=\"${taskPh}\">\n    <input type=\"text\" id=\"preview-spin\"  placeholder=\"${spinPh}\">\n  `;\n\n  container.querySelector('#preview-flavor')?.setAttribute('value', current.flavor);\n  const pFlavor = container.querySelector('#preview-flavor'); if (pFlavor) pFlavor.value = current.flavor;\n  container.querySelector('#preview-role')?.setAttribute('value', current.role);\n  const pRole   = container.querySelector('#preview-role');   if (pRole)   pRole.value   = current.role;\n  const pTask   = container.querySelector('#preview-task');   if (pTask)   pTask.value   = current.task;\n  const pSpin   = container.querySelector('#preview-spin');   if (pSpin)   pSpin.value   = current.spin;\n\n  const orderHint = html.querySelector('#order-hint');\n  if (orderHint) {\n    const names = { flavor: flavorPh, role: rolePh };\n    orderHint.textContent = `${names[previewOrder[0]]} → ${names[previewOrder[1]]}`;\n  }\n}\n\n// ----- 3. Inicialização -----\nlet selectedRows = roll10d40(BACKGROUND_TABLE);\n\n// ----- 4. DialogV2 -----\nawait foundry.applications.api.DialogV2.wait({\n  window: { title: game.i18n.localize('SDM.BackgroundGenerator') },\n  content: buildDialogContent(selectedRows),\n  buttons: [\n    {\n      action: 'confirm',\n      label: game.i18n.localize('SDM.BackgroundConfirm'),\n      callback: async (event, button, dialog) => {\n        const html = dialog.element;\n        const selected = { flavor: null, role1: null, role2: null, task: null, spin: null };\n\n        // Linhas selecionadas\n        html.querySelectorAll('tbody tr').forEach(tr => {\n          const rowIndex = parseInt(tr.dataset.row);\n          const rowCheckbox = tr.querySelector('.row-select');\n          if (rowCheckbox?.checked && !isNaN(rowIndex)) {\n            const rowData = selectedRows[rowIndex];\n            selected.flavor ??= rowData.flavor;\n            selected.role1  ??= rowData.role1;\n            selected.role2  ??= rowData.role2;\n            selected.task   ??= rowData.task;\n            selected.spin   ??= rowData.spin;\n          }\n        });\n\n        // Células selecionadas\n        html.querySelectorAll('.cell-select:checked').forEach(cb => {\n          const tr = cb.closest('tr');\n          if (!tr) return;\n          const rowIndex = parseInt(tr.dataset.row);\n          if (isNaN(rowIndex)) return;\n          selected[cb.dataset.col] = selectedRows[rowIndex][cb.dataset.col];\n        });\n\n        // Pega os DOIS primeiros campos em ordem visual e combina\n        const firstId  = `#preview-${previewOrder[0]}`;\n        const secondId = `#preview-${previewOrder[1]}`;\n        const roleAuto = (selected.role1 && selected.role2)\n          ? `${selected.role1} ${selected.role2}`\n          : (selected.role1 ?? selected.role2 ?? '');\n\n        const firstVal =\n          html.querySelector(firstId)?.value ||\n          (previewOrder[0] === 'flavor' ? selected.flavor : roleAuto);\n\n        const secondVal =\n          html.querySelector(secondId)?.value ||\n          (previewOrder[1] === 'flavor' ? selected.flavor : roleAuto);\n\n        const combined = [firstVal, secondVal].filter(Boolean).join(' ').replace(/\\s+/g, ' ').trim();\n\n        const task = html.querySelector('#preview-task')?.value || selected.task;\n        const spin = html.querySelector('#preview-spin')?.value || selected.spin;\n\n        actor = game.user?.character || canvas?.tokens?.controlled[0]?.actor;\n        if (!actor) {\n          ui.notifications.error(game.i18n.localize('SDM.BackgroundInvalidCharacter'));\n          return;\n        }\n        if (!combined) return;\n\n        await game.sdm.api.createBackgroundTrait(actor, {\n          title: combined,\n          task,\n          spin\n        });\n\n        ui.notifications.info(game.i18n.format(\"SDM.BackgroundTraitCreated\", {\n          flavor: combined,\n          role: '',\n          name: actor.name,\n        }));\n      }\n    },\n    { action: 'cancel', label: game.i18n.localize('SDM.BackgroundCancel') }\n  ],\n  render: (event, dialog) => {\n    const html = dialog.element;\n\n    function updatePreview() {\n      const selected = { flavor: null, role1: null, role2: null, task: null, spin: null };\n\n      // Use apenas tbody tr\n      html.querySelectorAll('tbody tr').forEach(tr => {\n        const rowIndex = parseInt(tr.dataset.row);\n        const rowCheckbox = tr.querySelector('.row-select');\n        if (rowCheckbox?.checked && !isNaN(rowIndex)) {\n          const rowData = selectedRows[rowIndex];\n          selected.flavor ??= rowData.flavor;\n          selected.role1  ??= rowData.role1;\n          selected.role2  ??= rowData.role2;\n          selected.task   ??= rowData.task;\n          selected.spin   ??= rowData.spin;\n        }\n      });\n\n      html.querySelectorAll('.cell-select:checked').forEach(cb => {\n        const tr = cb.closest('tr');\n        if (!tr) return;\n        const rowIndex = parseInt(tr.dataset.row);\n        if (isNaN(rowIndex)) return;\n        selected[cb.dataset.col] = selectedRows[rowIndex][cb.dataset.col];\n      });\n\n      const pFlavor = html.querySelector('#preview-flavor');\n      const pRole   = html.querySelector('#preview-role');\n      if (pFlavor) pFlavor.value = selected.flavor ?? '';\n      if (pRole)   pRole.value   = (selected.role1 && selected.role2)\n        ? `${selected.role1} ${selected.role2}`\n        : (selected.role1 ?? selected.role2 ?? '');\n\n      const pTask = html.querySelector('#preview-task');\n      const pSpin = html.querySelector('#preview-spin');\n      if (pTask) pTask.value = selected.task ?? '';\n      if (pSpin) pSpin.value = selected.spin ?? '';\n    }\n\n    function attachListeners() {\n      // Linhas\n      html.querySelectorAll('.row-select').forEach(cb => {\n        cb.addEventListener('change', () => {\n          const row = cb.closest('tr');\n          if (!row) return;\n          if (cb.checked) {\n            html.querySelectorAll('.row-select').forEach(other => {\n              if (other !== cb) other.checked = false;\n            });\n            html.querySelectorAll('.cell-select').forEach(c => (c.checked = false));\n            row.querySelectorAll('.cell-select').forEach(c => (c.checked = true));\n          } else {\n            row.querySelectorAll('.cell-select').forEach(c => (c.checked = false));\n          }\n          updatePreview();\n        });\n      });\n\n      // Células\n      html.querySelectorAll('.cell-select').forEach(cb => {\n        cb.addEventListener('change', () => {\n          const tr = cb.closest('tr');\n          if (!tr) return;\n          const rowCheckbox = tr.querySelector('.row-select');\n          if (cb.checked) {\n            html.querySelectorAll(`.cell-select[data-col=\"${cb.dataset.col}\"]`).forEach(c => {\n              if (c !== cb) c.checked = false;\n            });\n            if (rowCheckbox) rowCheckbox.checked = false;\n          }\n          updatePreview();\n        });\n      });\n    }\n\n    // Liga o botão de troca **uma única vez**\n    const swap = html.querySelector('#swap-order');\n    if (swap && !swap.dataset.bound) {\n      swap.addEventListener('click', () => {\n        previewOrder.reverse();\n        renderPreviewInputs(html);\n        updatePreview();\n      });\n      swap.dataset.bound = '1';\n    }\n\n    // Reroll\n    const reroll = html.querySelector('#reroll-dice');\n    reroll?.addEventListener('click', async () => {\n      if (!window.confirm(game.i18n.localize('SDM.BackgroundRerollConfirmation'))) return;\n      selectedRows = roll10d40(BACKGROUND_TABLE);\n\n      const tbody = html.querySelector('tbody');\n      if (tbody) {\n        tbody.innerHTML = buildDialogContent(selectedRows).match(/<tbody>([\\s\\S]*)<\\/tbody>/)[1];\n      }\n\n      // Reanexa apenas os listeners da TABELA (swap-order continua 1x)\n      attachListeners();\n\n      // Mantém a ordem atual do preview\n      renderPreviewInputs(html);\n      updatePreview();\n    });\n\n    // Primeira renderização\n    renderPreviewInputs(html);\n    attachListeners();\n    updatePreview();\n  }\n});",
  "img": "icons/sundries/documents/document-sealed-red-tan.webp",
  "author": "0fqTkfNvjooZ2og7",
  "scope": "global",
  "folder": null,
  "ownership": {
    "default": 0,
    "0fqTkfNvjooZ2og7": 3
  },
  "flags": {},
  "_stats": {
    "compendiumSource": null,
    "duplicateSource": null,
    "exportSource": null,
    "coreVersion": "13.348",
    "systemId": "sdm",
    "systemVersion": "0.1.36",
    "createdTime": 1756564474357,
    "modifiedTime": 1756564474357,
    "lastModifiedBy": "0fqTkfNvjooZ2og7"
  },
  "_id": "9pBprcUEtVijH31Y",
  "sort": 0,
  "_key": "!macros!9pBprcUEtVijH31Y"
}
